# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T02:58:49+00:00



import argparse
import json
import os
from typing import *
from typing import Optional

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity, UnsuportedSecurityStub
from fastapi import Path, Query, Request
from pydantic import conint

from models import (
    Alt,
    Bucket,
    BucketAccessControl,
    BucketAccessControls,
    Buckets,
    Channel,
    ComposeRequest,
    DestinationPredefinedAcl,
    HmacKey,
    HmacKeyMetadata,
    HmacKeysMetadata,
    Notification,
    Notifications,
    Object,
    ObjectAccessControl,
    ObjectAccessControls,
    Objects,
    Permissions,
    Policy,
    PredefinedAcl,
    PredefinedAcl6,
    PredefinedDefaultObjectAcl,
    Projection,
    RewriteResponse,
    ServiceAccount,
    TestIamPermissionsResponse,
)

app = MCPProxy(
    contact={'name': 'Google', 'url': 'https://google.com', 'x-twitter': 'youtube'},
    description='Stores and retrieves potentially large, immutable data objects.',
    license={
        'name': 'Creative Commons Attribution 3.0',
        'url': 'http://creativecommons.org/licenses/by/3.0/',
    },
    termsOfService='https://developers.google.com/terms/',
    title='Cloud Storage JSON API',
    version='v1',
    servers=[{'url': 'https://storage.googleapis.com/storage/v1'}],
)


@app.get(
    '/b',
    description=""" Retrieves a list of buckets for a given project. """,
    tags=['storage_service_account_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_buckets_list(
    project: str,
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    prefix: Optional[str] = None,
    projection: Optional[Projection] = None,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/b',
    description=""" Creates a new bucket. """,
    tags=[
        'storage_bucket_management',
        'storage_bucket_access_controls',
        'storage_default_access_controls',
        'storage_bucket_iam_policies',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_buckets_insert(
    project: str,
    predefined_acl: Optional[PredefinedAcl] = Query(None, alias='predefinedAcl'),
    predefined_default_object_acl: Optional[PredefinedDefaultObjectAcl] = Query(
        None, alias='predefinedDefaultObjectAcl'
    ),
    projection: Optional[Projection] = None,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Bucket = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/b/{bucket}',
    description=""" Permanently deletes an empty bucket. """,
    tags=['storage_bucket_management', 'storage_bucket_access_controls'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_buckets_delete(
    bucket: str,
    if_metageneration_match: Optional[str] = Query(None, alias='ifMetagenerationMatch'),
    if_metageneration_not_match: Optional[str] = Query(
        None, alias='ifMetagenerationNotMatch'
    ),
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/b/{bucket}',
    description=""" Returns metadata for the specified bucket. """,
    tags=['storage_bucket_management', 'storage_bucket_access_controls'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_buckets_get(
    bucket: str,
    if_metageneration_match: Optional[str] = Query(None, alias='ifMetagenerationMatch'),
    if_metageneration_not_match: Optional[str] = Query(
        None, alias='ifMetagenerationNotMatch'
    ),
    projection: Optional[Projection] = None,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/b/{bucket}',
    description=""" Patches a bucket. Changes to the bucket will be readable immediately after writing, but configuration changes may take time to propagate. """,
    tags=['storage_bucket_management', 'storage_bucket_access_controls'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_buckets_patch(
    bucket: str,
    if_metageneration_match: Optional[str] = Query(None, alias='ifMetagenerationMatch'),
    if_metageneration_not_match: Optional[str] = Query(
        None, alias='ifMetagenerationNotMatch'
    ),
    predefined_acl: Optional[PredefinedAcl] = Query(None, alias='predefinedAcl'),
    predefined_default_object_acl: Optional[PredefinedDefaultObjectAcl] = Query(
        None, alias='predefinedDefaultObjectAcl'
    ),
    projection: Optional[Projection] = None,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Bucket = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/b/{bucket}',
    description=""" Updates a bucket. Changes to the bucket will be readable immediately after writing, but configuration changes may take time to propagate. """,
    tags=['storage_bucket_management', 'storage_bucket_access_controls'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_buckets_update(
    bucket: str,
    if_metageneration_match: Optional[str] = Query(None, alias='ifMetagenerationMatch'),
    if_metageneration_not_match: Optional[str] = Query(
        None, alias='ifMetagenerationNotMatch'
    ),
    predefined_acl: Optional[PredefinedAcl] = Query(None, alias='predefinedAcl'),
    predefined_default_object_acl: Optional[PredefinedDefaultObjectAcl] = Query(
        None, alias='predefinedDefaultObjectAcl'
    ),
    projection: Optional[Projection] = None,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Bucket = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/b/{bucket}/acl',
    description=""" Retrieves ACL entries on the specified bucket. """,
    tags=[
        'storage_bucket_management',
        'storage_bucket_access_controls',
        'storage_bucket_iam_policies',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_bucket_access_controls_list(
    bucket: str,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/b/{bucket}/acl',
    description=""" Creates a new ACL entry on the specified bucket. """,
    tags=['storage_bucket_access_controls'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_bucket_access_controls_insert(
    bucket: str,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: BucketAccessControl = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/b/{bucket}/acl/{entity}',
    description=""" Permanently deletes the ACL entry for the specified entity on the specified bucket. """,
    tags=['storage_bucket_management', 'storage_object_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_bucket_access_controls_delete(
    bucket: str,
    entity: str = ...,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/b/{bucket}/acl/{entity}',
    description=""" Returns the ACL entry for the specified entity on the specified bucket. """,
    tags=['storage_bucket_access_controls', 'storage_bucket_iam_policies'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_bucket_access_controls_get(
    bucket: str,
    entity: str = ...,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/b/{bucket}/acl/{entity}',
    description=""" Patches an ACL entry on the specified bucket. """,
    tags=['storage_bucket_access_controls'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_bucket_access_controls_patch(
    bucket: str,
    entity: str = ...,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: BucketAccessControl = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/b/{bucket}/acl/{entity}',
    description=""" Updates an ACL entry on the specified bucket. """,
    tags=['storage_bucket_access_controls'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_bucket_access_controls_update(
    bucket: str,
    entity: str = ...,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: BucketAccessControl = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/b/{bucket}/defaultObjectAcl',
    description=""" Retrieves default object ACL entries on the specified bucket. """,
    tags=[
        'storage_bucket_management',
        'storage_bucket_access_controls',
        'storage_bucket_iam_policies',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_default_object_access_controls_list(
    bucket: str,
    if_metageneration_match: Optional[str] = Query(None, alias='ifMetagenerationMatch'),
    if_metageneration_not_match: Optional[str] = Query(
        None, alias='ifMetagenerationNotMatch'
    ),
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/b/{bucket}/defaultObjectAcl',
    description=""" Creates a new default object ACL entry on the specified bucket. """,
    tags=['storage_bucket_access_controls', 'storage_default_access_controls'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_default_object_access_controls_insert(
    bucket: str,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: ObjectAccessControl = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/b/{bucket}/defaultObjectAcl/{entity}',
    description=""" Permanently deletes the default object ACL entry for the specified entity on the specified bucket. """,
    tags=[
        'storage_bucket_management',
        'storage_bucket_access_controls',
        'storage_bucket_iam_policies',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_default_object_access_controls_delete(
    bucket: str,
    entity: str = ...,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/b/{bucket}/defaultObjectAcl/{entity}',
    description=""" Returns the default object ACL entry for the specified entity on the specified bucket. """,
    tags=['storage_bucket_access_controls', 'storage_bucket_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_default_object_access_controls_get(
    bucket: str,
    entity: str = ...,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/b/{bucket}/defaultObjectAcl/{entity}',
    description=""" Patches a default object ACL entry on the specified bucket. """,
    tags=['storage_object_access_controls', 'storage_bucket_access_controls'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_default_object_access_controls_patch(
    bucket: str,
    entity: str = ...,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: ObjectAccessControl = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/b/{bucket}/defaultObjectAcl/{entity}',
    description=""" Updates a default object ACL entry on the specified bucket. """,
    tags=['storage_bucket_access_controls', 'storage_default_access_controls'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_default_object_access_controls_update(
    bucket: str,
    entity: str = ...,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: ObjectAccessControl = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/b/{bucket}/iam',
    description=""" Returns an IAM policy for the specified bucket. """,
    tags=[
        'storage_bucket_management',
        'storage_bucket_access_controls',
        'storage_bucket_iam_policies',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_buckets_get_iam_policy(
    bucket: str,
    options_requested_policy_version: Optional[conint(ge=1)] = Query(
        None, alias='optionsRequestedPolicyVersion'
    ),
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/b/{bucket}/iam',
    description=""" Updates an IAM policy for the specified bucket. """,
    tags=['storage_bucket_access_controls', 'storage_bucket_iam_policies'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_buckets_set_iam_policy(
    bucket: str,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Policy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/b/{bucket}/iam/testPermissions',
    description=""" Tests a set of permissions on the given bucket to see which, if any, are held by the caller. """,
    tags=['storage_bucket_access_controls', 'storage_bucket_iam_policies'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_buckets_test_iam_permissions(
    bucket: str,
    permissions: Permissions = ...,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/b/{bucket}/lockRetentionPolicy',
    description=""" Locks retention policy on a bucket. """,
    tags=[
        'storage_bucket_management',
        'storage_bucket_access_controls',
        'storage_bucket_iam_policies',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_buckets_lock_retention_policy(
    bucket: str,
    if_metageneration_match: str = Query(..., alias='ifMetagenerationMatch'),
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/b/{bucket}/notificationConfigs',
    description=""" Retrieves a list of notification subscriptions for a given bucket. """,
    tags=[
        'storage_bucket_management',
        'storage_bucket_access_controls',
        'storage_bucket_iam_policies',
        'storage_default_access_controls',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_notifications_list(
    bucket: str,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/b/{bucket}/notificationConfigs',
    description=""" Creates a notification subscription for a given bucket. """,
    tags=['storage_bucket_event_notifications'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_notifications_insert(
    bucket: str,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Notification = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/b/{bucket}/notificationConfigs/{notification}',
    description=""" Permanently deletes a notification subscription. """,
    tags=['storage_bucket_event_notifications'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_notifications_delete(
    bucket: str,
    notification: str = ...,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/b/{bucket}/notificationConfigs/{notification}',
    description=""" View a notification configuration. """,
    tags=['storage_bucket_event_notifications'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_notifications_get(
    bucket: str,
    notification: str = ...,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/b/{bucket}/o',
    description=""" Retrieves a list of objects matching the criteria. """,
    tags=['storage_bucket_management', 'storage_object_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_objects_list(
    bucket: str,
    delimiter: Optional[str] = None,
    end_offset: Optional[str] = Query(None, alias='endOffset'),
    include_trailing_delimiter: Optional[bool] = Query(
        None, alias='includeTrailingDelimiter'
    ),
    match_glob: Optional[str] = Query(None, alias='matchGlob'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    prefix: Optional[str] = None,
    projection: Optional[Projection] = None,
    start_offset: Optional[str] = Query(None, alias='startOffset'),
    user_project: Optional[str] = Query(None, alias='userProject'),
    versions: Optional[bool] = None,
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/b/{bucket}/o',
    description=""" Stores a new object and metadata. """,
    tags=[
        'storage_bucket_management',
        'storage_bucket_access_controls',
        'storage_bucket_iam_policies',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_objects_insert(
    bucket: str,
    content_encoding: Optional[str] = Query(None, alias='contentEncoding'),
    if_generation_match: Optional[str] = Query(None, alias='ifGenerationMatch'),
    if_generation_not_match: Optional[str] = Query(None, alias='ifGenerationNotMatch'),
    if_metageneration_match: Optional[str] = Query(None, alias='ifMetagenerationMatch'),
    if_metageneration_not_match: Optional[str] = Query(
        None, alias='ifMetagenerationNotMatch'
    ),
    kms_key_name: Optional[str] = Query(None, alias='kmsKeyName'),
    name: Optional[str] = None,
    predefined_acl: Optional[PredefinedAcl6] = Query(None, alias='predefinedAcl'),
    projection: Optional[Projection] = None,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    request: Request = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/b/{bucket}/o/watch',
    description=""" Watch for changes on all objects in a bucket. """,
    tags=['storage_object_management', 'storage_object_access_controls'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_objects_watch_all(
    bucket: str,
    delimiter: Optional[str] = None,
    end_offset: Optional[str] = Query(None, alias='endOffset'),
    include_trailing_delimiter: Optional[bool] = Query(
        None, alias='includeTrailingDelimiter'
    ),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    prefix: Optional[str] = None,
    projection: Optional[Projection] = None,
    start_offset: Optional[str] = Query(None, alias='startOffset'),
    user_project: Optional[str] = Query(None, alias='userProject'),
    versions: Optional[bool] = None,
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Channel = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/b/{bucket}/o/{object}',
    description=""" Deletes an object and its metadata. Deletions are permanent if versioning is not enabled for the bucket, or if the generation parameter is used. """,
    tags=['storage_object_management', 'storage_object_access_controls'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_objects_delete(
    bucket: str,
    object: str = ...,
    generation: Optional[str] = None,
    if_generation_match: Optional[str] = Query(None, alias='ifGenerationMatch'),
    if_generation_not_match: Optional[str] = Query(None, alias='ifGenerationNotMatch'),
    if_metageneration_match: Optional[str] = Query(None, alias='ifMetagenerationMatch'),
    if_metageneration_not_match: Optional[str] = Query(
        None, alias='ifMetagenerationNotMatch'
    ),
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/b/{bucket}/o/{object}',
    description=""" Retrieves an object or its metadata. """,
    tags=['storage_object_management', 'storage_object_access_controls'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_objects_get(
    bucket: str,
    object: str = ...,
    generation: Optional[str] = None,
    if_generation_match: Optional[str] = Query(None, alias='ifGenerationMatch'),
    if_generation_not_match: Optional[str] = Query(None, alias='ifGenerationNotMatch'),
    if_metageneration_match: Optional[str] = Query(None, alias='ifMetagenerationMatch'),
    if_metageneration_not_match: Optional[str] = Query(
        None, alias='ifMetagenerationNotMatch'
    ),
    projection: Optional[Projection] = None,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/b/{bucket}/o/{object}',
    description=""" Patches an object's metadata. """,
    tags=['storage_object_management', 'storage_object_access_controls'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_objects_patch(
    bucket: str,
    object: str = ...,
    generation: Optional[str] = None,
    if_generation_match: Optional[str] = Query(None, alias='ifGenerationMatch'),
    if_generation_not_match: Optional[str] = Query(None, alias='ifGenerationNotMatch'),
    if_metageneration_match: Optional[str] = Query(None, alias='ifMetagenerationMatch'),
    if_metageneration_not_match: Optional[str] = Query(
        None, alias='ifMetagenerationNotMatch'
    ),
    predefined_acl: Optional[PredefinedAcl6] = Query(None, alias='predefinedAcl'),
    projection: Optional[Projection] = None,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Object = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/b/{bucket}/o/{object}',
    description=""" Updates an object's metadata. """,
    tags=['storage_object_management', 'storage_object_access_controls'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_objects_update(
    bucket: str,
    object: str = ...,
    generation: Optional[str] = None,
    if_generation_match: Optional[str] = Query(None, alias='ifGenerationMatch'),
    if_generation_not_match: Optional[str] = Query(None, alias='ifGenerationNotMatch'),
    if_metageneration_match: Optional[str] = Query(None, alias='ifMetagenerationMatch'),
    if_metageneration_not_match: Optional[str] = Query(
        None, alias='ifMetagenerationNotMatch'
    ),
    predefined_acl: Optional[PredefinedAcl6] = Query(None, alias='predefinedAcl'),
    projection: Optional[Projection] = None,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Object = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/b/{bucket}/o/{object}/acl',
    description=""" Retrieves ACL entries on the specified object. """,
    tags=['storage_object_management', 'storage_object_access_controls'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_object_access_controls_list(
    bucket: str,
    object: str = ...,
    generation: Optional[str] = None,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/b/{bucket}/o/{object}/acl',
    description=""" Creates a new ACL entry on the specified object. """,
    tags=['storage_object_access_controls', 'storage_object_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_object_access_controls_insert(
    bucket: str,
    object: str = ...,
    generation: Optional[str] = None,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: ObjectAccessControl = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/b/{bucket}/o/{object}/acl/{entity}',
    description=""" Permanently deletes the ACL entry for the specified entity on the specified object. """,
    tags=[
        'storage_object_access_controls',
        'storage_object_management',
        'storage_object_iam_policies',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_object_access_controls_delete(
    bucket: str,
    object: str = ...,
    entity: str = ...,
    generation: Optional[str] = None,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/b/{bucket}/o/{object}/acl/{entity}',
    description=""" Returns the ACL entry for the specified entity on the specified object. """,
    tags=['storage_object_access_controls', 'storage_object_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_object_access_controls_get(
    bucket: str,
    object: str = ...,
    entity: str = ...,
    generation: Optional[str] = None,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/b/{bucket}/o/{object}/acl/{entity}',
    description=""" Patches an ACL entry on the specified object. """,
    tags=['storage_object_access_controls', 'storage_object_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_object_access_controls_patch(
    bucket: str,
    object: str = ...,
    entity: str = ...,
    generation: Optional[str] = None,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: ObjectAccessControl = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/b/{bucket}/o/{object}/acl/{entity}',
    description=""" Updates an ACL entry on the specified object. """,
    tags=['storage_object_access_controls', 'storage_object_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_object_access_controls_update(
    bucket: str,
    object: str = ...,
    entity: str = ...,
    generation: Optional[str] = None,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: ObjectAccessControl = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/b/{bucket}/o/{object}/iam',
    description=""" Returns an IAM policy for the specified object. """,
    tags=['storage_object_management', 'storage_object_access_controls'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_objects_get_iam_policy(
    bucket: str,
    object: str = ...,
    generation: Optional[str] = None,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/b/{bucket}/o/{object}/iam',
    description=""" Updates an IAM policy for the specified object. """,
    tags=['storage_bucket_access_controls', 'storage_object_access_controls'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_objects_set_iam_policy(
    bucket: str,
    object: str = ...,
    generation: Optional[str] = None,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Policy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/b/{bucket}/o/{object}/iam/testPermissions',
    description=""" Tests a set of permissions on the given object to see which, if any, are held by the caller. """,
    tags=['storage_object_access_controls', 'storage_object_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_objects_test_iam_permissions(
    bucket: str,
    object: str = ...,
    permissions: Permissions = ...,
    generation: Optional[str] = None,
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/b/{destinationBucket}/o/{destinationObject}/compose',
    description=""" Concatenates a list of existing objects into a new object in the same bucket. """,
    tags=['storage_object_management', 'storage_object_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_objects_compose(
    destination_bucket: str = Path(..., alias='destinationBucket'),
    destination_object: str = Path(..., alias='destinationObject'),
    destination_predefined_acl: Optional[DestinationPredefinedAcl] = Query(
        None, alias='destinationPredefinedAcl'
    ),
    if_generation_match: Optional[str] = Query(None, alias='ifGenerationMatch'),
    if_metageneration_match: Optional[str] = Query(None, alias='ifMetagenerationMatch'),
    kms_key_name: Optional[str] = Query(None, alias='kmsKeyName'),
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: ComposeRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/b/{sourceBucket}/o/{sourceObject}/copyTo/b/{destinationBucket}/o/{destinationObject}',
    description=""" Copies a source object to a destination object. Optionally overrides metadata. """,
    tags=['storage_object_management', 'storage_object_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_objects_copy(
    source_bucket: str = Path(..., alias='sourceBucket'),
    source_object: str = Path(..., alias='sourceObject'),
    destination_bucket: str = Path(..., alias='destinationBucket'),
    destination_object: str = Path(..., alias='destinationObject'),
    destination_kms_key_name: Optional[str] = Query(
        None, alias='destinationKmsKeyName'
    ),
    destination_predefined_acl: Optional[DestinationPredefinedAcl] = Query(
        None, alias='destinationPredefinedAcl'
    ),
    if_generation_match: Optional[str] = Query(None, alias='ifGenerationMatch'),
    if_generation_not_match: Optional[str] = Query(None, alias='ifGenerationNotMatch'),
    if_metageneration_match: Optional[str] = Query(None, alias='ifMetagenerationMatch'),
    if_metageneration_not_match: Optional[str] = Query(
        None, alias='ifMetagenerationNotMatch'
    ),
    if_source_generation_match: Optional[str] = Query(
        None, alias='ifSourceGenerationMatch'
    ),
    if_source_generation_not_match: Optional[str] = Query(
        None, alias='ifSourceGenerationNotMatch'
    ),
    if_source_metageneration_match: Optional[str] = Query(
        None, alias='ifSourceMetagenerationMatch'
    ),
    if_source_metageneration_not_match: Optional[str] = Query(
        None, alias='ifSourceMetagenerationNotMatch'
    ),
    projection: Optional[Projection] = None,
    source_generation: Optional[str] = Query(None, alias='sourceGeneration'),
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Object = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/b/{sourceBucket}/o/{sourceObject}/rewriteTo/b/{destinationBucket}/o/{destinationObject}',
    description=""" Rewrites a source object to a destination object. Optionally overrides metadata. """,
    tags=['storage_object_operations', 'storage_object_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_objects_rewrite(
    source_bucket: str = Path(..., alias='sourceBucket'),
    source_object: str = Path(..., alias='sourceObject'),
    destination_bucket: str = Path(..., alias='destinationBucket'),
    destination_object: str = Path(..., alias='destinationObject'),
    destination_kms_key_name: Optional[str] = Query(
        None, alias='destinationKmsKeyName'
    ),
    destination_predefined_acl: Optional[DestinationPredefinedAcl] = Query(
        None, alias='destinationPredefinedAcl'
    ),
    if_generation_match: Optional[str] = Query(None, alias='ifGenerationMatch'),
    if_generation_not_match: Optional[str] = Query(None, alias='ifGenerationNotMatch'),
    if_metageneration_match: Optional[str] = Query(None, alias='ifMetagenerationMatch'),
    if_metageneration_not_match: Optional[str] = Query(
        None, alias='ifMetagenerationNotMatch'
    ),
    if_source_generation_match: Optional[str] = Query(
        None, alias='ifSourceGenerationMatch'
    ),
    if_source_generation_not_match: Optional[str] = Query(
        None, alias='ifSourceGenerationNotMatch'
    ),
    if_source_metageneration_match: Optional[str] = Query(
        None, alias='ifSourceMetagenerationMatch'
    ),
    if_source_metageneration_not_match: Optional[str] = Query(
        None, alias='ifSourceMetagenerationNotMatch'
    ),
    max_bytes_rewritten_per_call: Optional[str] = Query(
        None, alias='maxBytesRewrittenPerCall'
    ),
    projection: Optional[Projection] = None,
    rewrite_token: Optional[str] = Query(None, alias='rewriteToken'),
    source_generation: Optional[str] = Query(None, alias='sourceGeneration'),
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Object = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/channels/stop',
    description=""" Stop watching resources through this channel """,
    tags=[
        'storage_bucket_management',
        'storage_bucket_access_controls',
        'storage_bucket_iam_policies',
        'storage_bucket_event_notifications',
        'storage_object_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_channels_stop(
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Channel = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{projectId}/hmacKeys',
    description=""" Retrieves a list of HMAC keys matching the criteria. """,
    tags=['storage_service_account_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_projects_hmac_keys_list(
    project_id: str = Path(..., alias='projectId'),
    max_results: Optional[conint(ge=0)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    service_account_email: Optional[str] = Query(None, alias='serviceAccountEmail'),
    show_deleted_keys: Optional[bool] = Query(None, alias='showDeletedKeys'),
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{projectId}/hmacKeys',
    description=""" Creates a new HMAC key for the specified service account. """,
    tags=['storage_service_account_management', 'storage_bucket_iam_policies'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_projects_hmac_keys_create(
    project_id: str = Path(..., alias='projectId'),
    service_account_email: str = Query(..., alias='serviceAccountEmail'),
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{projectId}/hmacKeys/{accessId}',
    description=""" Deletes an HMAC key. """,
    tags=[
        'storage_bucket_access_controls',
        'storage_default_access_controls',
        'storage_bucket_iam_policies',
        'storage_object_access_controls',
        'storage_hmac_key_management',
        'storage_service_account_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_projects_hmac_keys_delete(
    project_id: str = Path(..., alias='projectId'),
    access_id: str = Path(..., alias='accessId'),
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{projectId}/hmacKeys/{accessId}',
    description=""" Retrieves an HMAC key's metadata """,
    tags=[
        'storage_bucket_access_controls',
        'storage_bucket_iam_policies',
        'storage_object_access_controls',
        'storage_service_account_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_projects_hmac_keys_get(
    project_id: str = Path(..., alias='projectId'),
    access_id: str = Path(..., alias='accessId'),
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/projects/{projectId}/hmacKeys/{accessId}',
    description=""" Updates the state of an HMAC key. See the HMAC Key resource descriptor for valid states. """,
    tags=['storage_hmac_key_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_projects_hmac_keys_update(
    project_id: str = Path(..., alias='projectId'),
    access_id: str = Path(..., alias='accessId'),
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: HmacKeyMetadata = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{projectId}/serviceAccount',
    description=""" Get the email address of this project's Google Cloud Storage service account. """,
    tags=[
        'storage_bucket_management',
        'storage_bucket_access_controls',
        'storage_default_access_controls',
        'storage_bucket_iam_policies',
        'storage_bucket_event_notifications',
        'storage_object_management',
        'storage_object_access_controls',
        'storage_object_iam_policies',
        'storage_object_operations',
        'storage_hmac_key_management',
        'storage_service_account_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def storage_projects_service_account_get(
    project_id: str = Path(..., alias='projectId'),
    user_project: Optional[str] = Query(None, alias='userProject'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
